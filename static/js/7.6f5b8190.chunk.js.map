{"version":3,"sources":["config.tsx","redux/hook.tsx","utils/getRPC.tsx","hooks/walletTokenNetwork.tsx","hooks/useAuth.tsx","utils/connectors.tsx","redux/triedEager.tsx","hooks/useEagerConnect.tsx","hooks/useInactiveListener.tsx","utils/baseConnection.tsx","App.tsx"],"names":["config","chainId","process","rpc_url1","rpc_url2","backend_url","useAppDispatch","useDispatch","useAppSelector","useSelector","Error","RPC_NODES","getRPCNodeUrl","url","sample","undefined","chainID","getChainID","parseInt","setupNetwork","a","provider","window","ethereum","request","method","params","toString","code","chainName","nativeCurrency","name","symbol","decimals","rpcUrls","blockExplorerUrls","console","error","useAuth","dispatch","useWeb3React","active","connector","activate","deactivate","injected","localStorage","setItem","walletconnect","logout","useCallback","setState","getItem","handleDisconnect","removeItem","login","connectorId","currentConnector","connectorType","UnsupportedChainIdError","catch","NoEthereumProviderError","log","UserRejectedRequestErrorInjected","UserRejectedRequestErrorWalletConnect","message","RPC_URL","CHAIN_ID","NaN","InjectedConnector","supportedChainIds","handleChainChanged","newChainID","emitDeactivate","emitUpdate","BinanceChain","location","reload","WalletConnectConnector","rpc","bridge","qrcode","pollingInterval","getLibrary","Web3","triedEagerSlice","createSlice","initialState","tried","reducers","state","action","payload","actions","useEagerConnect","useEffect","useInactiveListener","suppress","connectedWallet","on","handleConnect","handleAccountsChanged","accounts","length","handleNetworkChanged","networkId","removeListener","BaseConnector","triedEager","WalletModal","lazy","Routes","Header","Footer","Ending","App"],"mappings":"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","file":"static/js/7.6f5b8190.chunk.js","sourcesContent":["// require('dotenv').config();\n\nif (process.env.NODE_ENV === 'production') {\n    if (!process.env.REACT_APP_ETH_MAINNET_RPC_URL_1 || !process.env.REACT_APP_ETH_MAINNET_RPC_URL_2) {\n        console.error('Missing RPC url!!');\n        process.exit(1);\n    }\n    if (!process.env.REACT_APP_BACKEND_URL) {\n        console.error('Missing backend url!!');\n        process.exit(1);\n    }\n}\n\nconst config = {\n    chainId: process.env.REACT_APP_ETH_MAINNET_CHAIN_ID || '1',\n    rpc_url1: process.env.REACT_APP_ETH_MAINNET_RPC_URL_1 || '',\n    rpc_url2: process.env.REACT_APP_ETH_MAINNET_RPC_URL_2 || '',\n\n    backend_url: process.env.REACT_APP_BACKEND_URL || '',\n};\n\nexport default config;\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import sample from 'lodash/sample';\nimport config from '../config';\n\n// Error check \".env\" file for BSC_RPC_URL\nif (!config.rpc_url1 || !config.rpc_url2) {\n    throw Error('ETH_RPC_URLs is undefined');\n}\n\n// Array of available nodes to connect to Binance Smart Chain\nexport const RPC_NODES = [config.rpc_url1, config.rpc_url2];\n\nconst getRPCNodeUrl = (): string | undefined => {\n    // get URL\n    const url = sample(RPC_NODES);\n\n    // return undefined if failed to extract valid URL\n    if (url === undefined) {\n        return undefined;\n    }\n\n    // return valid string URL\n    return url;\n};\n\n// Error check \".env\" file for BSC_CHAIN_ID\nif (config.chainId === undefined) {\n    throw new Error('BSC_CHAIN_ID is undefined');\n}\n\nconst chainID = config.chainId;\n\nconst getChainID = () => {\n    return parseInt(chainID, 10);\n};\n\nexport { getRPCNodeUrl, getChainID };\n","import { getChainID, getRPCNodeUrl } from '../utils/getRPC';\n\nexport const setupNetwork = async () => {\n    const provider = window.ethereum;\n\n    if (provider) {\n        const chainId = getChainID();\n        try {\n            try {\n                await provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: `0x${chainId.toString(16)}` }],\n                });\n                return true;\n            } catch (switchError) {\n                // This error code indicates that the chain has not been added to MetaMask.\n                if ((switchError as any).code === 4902) {\n                    try {\n                        await provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [\n                                {\n                                    chainId: `0x${chainId.toString(16)}`,\n                                    chainName: 'Ethereum Mainnet',\n                                    nativeCurrency: {\n                                        name: 'ETH',\n                                        symbol: 'eth',\n                                        decimals: 18,\n                                    },\n                                    rpcUrls: [getRPCNodeUrl()],\n                                    blockExplorerUrls: ['https://etherscan.io'],\n                                },\n                            ],\n                        });\n                        return true;\n                    } catch (addError) {\n                        // handle \"add\" error\n                        console.error('add', addError);\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            }\n        } catch (error) {\n            console.error('setup', error);\n            return false;\n        }\n    } else {\n        console.error(\"Can't setup the BSC network on metamask because window.ethereum is undefined\");\n        return false;\n    }\n};\n\nexport const registerToken = async (\n    tokenAddress: string,\n    tokenSymbol: string,\n    tokenDecimals: number,\n    tokenImage: string,\n) => {\n    const provider = window.ethereum;\n\n    const tokenAdded = await (provider as any).request({\n        method: 'wallet_watchAsset',\n        params: {\n            type: 'ERC20',\n            options: {\n                address: tokenAddress,\n                symbol: tokenSymbol,\n                decimals: tokenDecimals,\n                image: tokenImage,\n            },\n        },\n    });\n\n    return tokenAdded;\n};\n","// import necessary library\nimport { useCallback } from 'react';\nimport { useWeb3React, UnsupportedChainIdError } from '@web3-react/core';\nimport {\n    NoEthereumProviderError,\n    UserRejectedRequestError as UserRejectedRequestErrorInjected,\n} from '@web3-react/injected-connector';\n\nimport { UserRejectedRequestError as UserRejectedRequestErrorWalletConnect } from '@web3-react/walletconnect-connector';\n\n// import local components\nimport { injected, walletconnect } from '../utils/connectors';\nimport { useAppDispatch } from '../redux/hook';\nimport { setState } from '../redux/triedEager';\nimport { setupNetwork } from './walletTokenNetwork';\n\nconst useAuth = () => {\n    const dispatch = useAppDispatch();\n    const { active, connector, activate, deactivate } = useWeb3React();\n\n    if (active) {\n        if (connector == injected) {\n            localStorage.setItem('_iris_fintech_', 'Injected');\n        } else if (connector == walletconnect) {\n            localStorage.setItem('_iris_fintech_', 'WalletConnect');\n        }\n    }\n\n    const logout = useCallback(() => {\n        dispatch(setState(false));\n        deactivate();\n\n        if (localStorage.getItem('_iris_fintech_') == 'WalletConnect') {\n            (walletconnect as any).handleDisconnect();\n        }\n\n        localStorage.removeItem('_iris_fintech_');\n        localStorage.removeItem('walletconnect');\n    }, [deactivate, dispatch]);\n\n    const login = useCallback(\n        (connectorId) => {\n            var currentConnector: any;\n            if (connectorId == 'Injected') {\n                currentConnector = injected;\n            } else if (connectorId == 'WalletConnect') {\n                currentConnector = walletconnect;\n            } else {\n                const connectorType = localStorage.getItem('_iris_fintech_');\n                if (connectorType == 'Injected') {\n                    currentConnector = injected;\n                } else if (connectorType == 'WalletConnect') {\n                    currentConnector = walletconnect;\n                }\n            }\n\n            if (currentConnector) {\n                activate(currentConnector, async (error: Error) => {\n                    if (error instanceof UnsupportedChainIdError) {\n                        if (currentConnector == injected) {\n                            const hasSetup = await setupNetwork();\n\n                            if (hasSetup) {\n                                activate(currentConnector, undefined, true).catch(() => {\n                                    dispatch(setState(true));\n                                });\n                            } else {\n                                logout();\n                            }\n                        } else if (currentConnector == walletconnect) {\n                            currentConnector.handleDisconnect();\n\n                            logout();\n                        }\n                    } else {\n                        if (error instanceof NoEthereumProviderError) {\n                            console.log('Provider Error', 'No provider was found');\n                        } else if (error instanceof UserRejectedRequestErrorInjected) {\n                            console.log('Authorization Error', 'Please authorize to access your account');\n                        } else if (error instanceof UserRejectedRequestErrorWalletConnect) {\n                            currentConnector.handleDisconnect();\n                            console.log('Authorization Error', 'Please authorize to access your account');\n                        } else {\n                            console.log(error.name, error.message);\n                        }\n                        logout();\n                    }\n                }).catch(() => {\n                    dispatch(setState(true));\n                    logout();\n                });\n            } else {\n                console.log(\"Can't find connector\", 'The connector config is wrong');\n                logout();\n            }\n        },\n        [activate, dispatch, logout],\n    );\n\n    return { login, logout };\n};\n\nexport default useAuth;\n","// Library Import\nimport { InjectedConnector } from '@web3-react/injected-connector';\nimport { WalletConnectConnector } from '@web3-react/walletconnect-connector';\nimport Web3 from 'web3';\n\n// Import TSX File\nimport { getRPCNodeUrl, getChainID } from './getRPC';\n\n// Define Constants\n// const POLLING_INTERVAL: number = 12000;\nconst RPC_URL: string | undefined = getRPCNodeUrl();\nconst CHAIN_ID: number = getChainID();\n\n// Type Check: RPC_URL should be valid string\nif (RPC_URL === undefined) {\n    throw new Error('URL Type Error: should be string');\n}\n\n// Type Check: CHAIN_ID should be valid Number\nif (CHAIN_ID === NaN) {\n    throw new Error('Invalid Numneric Error: should be a valid number');\n}\n\n// Connect to Inject Connector\nexport const injected = new InjectedConnector({\n    supportedChainIds: [CHAIN_ID],\n});\n\n//@ts-ignore\ninjected.handleChainChanged = (newChainID: string | number) => {\n    if (newChainID != CHAIN_ID) {\n        localStorage.removeItem('_iris_fintech_');\n\n        //@ts-ignore\n        injected.emitDeactivate();\n\n        return;\n    }\n\n    //@ts-ignore\n    injected.emitUpdate({ chainId: newChainID, provider: window.BinanceChain });\n\n    window.location.reload();\n};\n\n// Connect to Walletconnect Connector\nconst POLLING_INTERVAL = 12000;\n\nexport const walletconnect = new WalletConnectConnector({\n    rpc: { 1: RPC_URL },\n    bridge: 'https://bridge.walletconnect.org',\n    qrcode: true,\n    pollingInterval: POLLING_INTERVAL,\n});\n\n// getLibrary function for Web3Provider\nexport const getLibrary = (provider: any): Web3 => {\n    const library = new Web3(provider);\n    return library;\n};\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nexport const triedEagerSlice = createSlice({\n    name: 'triedEager',\n    initialState: {\n        tried: false,\n    },\n    reducers: {\n        setState: (state, action: PayloadAction<boolean>) => {\n            state.tried = action.payload;\n        },\n    },\n});\n\n// Action creators are generated for each case reducer function\nexport const { setState } = triedEagerSlice.actions;\n\nexport default triedEagerSlice.reducer;\n","import { useEffect } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport { useAppDispatch } from '../redux/hook';\nimport useAuth from './useAuth';\n\nconst useEagerConnect = () => {\n    const { activate } = useWeb3React();\n    const dispatch = useAppDispatch();\n    const { login } = useAuth();\n\n    useEffect(() => {\n        const connecetedWallet = localStorage.getItem('_iris_fintech_');\n\n        if (connecetedWallet) {\n            login('useEagerConnect');\n        }\n    }, [activate, dispatch, login]); // intentionally only running on mount (make sure it's only mounted once :))\n};\n\nexport default useEagerConnect;\n","import { useEffect } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport useAuth from './useAuth';\n\nconst useInactiveListener = (suppress: boolean = false) => {\n    const { connector, active, error } = useWeb3React();\n    const connectedWallet = localStorage.getItem('_iris_fintech_') ?? '';\n    const { login } = useAuth();\n\n    useEffect((): any => {\n        if (connector && connector.on && !active && !error && !suppress) {\n            const handleConnect = () => {\n                console.log(\"Handling 'connect' event\");\n                login('useInactiveListener');\n            };\n            const handleChainChanged = (chainId: string | number) => {\n                console.log(\"Handling 'chainChanged' event with payload\", chainId);\n                window.location.reload();\n                login('useInactiveListener');\n            };\n            const handleAccountsChanged = (accounts: string[]) => {\n                console.log(\"Handling 'accountsChanged' event with payload\", accounts);\n                if (accounts.length > 0) {\n                    login('useInactiveListener');\n                }\n            };\n            const handleNetworkChanged = (networkId: string | number) => {\n                console.log(\"Handling 'networkChanged' event with payload\", networkId);\n                login('useInactiveListener');\n            };\n\n            connector.on('connect', handleConnect);\n            connector.on('chainChanged', handleChainChanged);\n            connector.on('accountsChanged', handleAccountsChanged);\n            connector.on('networkChanged', handleNetworkChanged);\n\n            return () => {\n                if (connector.removeListener) {\n                    connector.removeListener('connect', handleConnect);\n                    connector.removeListener('chainChanged', handleChainChanged);\n                    connector.removeListener('accountsChanged', handleAccountsChanged);\n                    connector.removeListener('networkChanged', handleNetworkChanged);\n                }\n            };\n        }\n    }, [active, error, suppress, connector, login, connectedWallet]);\n};\n\nexport default useInactiveListener;\n","import useEagerConnect from '../hooks/useEagerConnect';\nimport useInactiveListener from '../hooks/useInactiveListener';\nimport { useAppSelector } from '../redux/hook';\n\nconst BaseConnector = () => {\n    const triedEager = useAppSelector((state) => state.triedEager.tried);\n\n    // handle logic to eagerly connect to the injected ethereum provider, if it exists and has granted access already\n    useEagerConnect();\n\n    // handle logic to connect in reaction to certain events on the injected ethereum provider, if it exists\n    useInactiveListener(!triedEager);\n};\n\nexport default BaseConnector;\n","import React, { lazy } from 'react';\n\nconst WalletModal = lazy(() => import('./components/WalletModal'));\nconst Routes = lazy(() => import('./route'));\nconst Header = lazy(() => import('./components/Header'));\nconst Footer = lazy(() => import('./components/Footer'));\nconst Ending = lazy(() => import('./components/Ending'));\n// const Account = lazy(() => import('./components/Account'));\n\nimport BaseConnector from './utils/baseConnection';\n\nconst App = () => {\n    BaseConnector();\n\n    return (\n        <div>\n            <Header />\n            <Routes />\n            <WalletModal />\n            {/* <Account /> */}\n            <Ending />\n            <Footer />\n        </div>\n    );\n};\n\nexport default App;\n"],"sourceRoot":""}