{"version":3,"sources":["redux/hook.tsx","utils/getRPC.tsx","hooks/walletTokenNetwork.tsx","hooks/useAuth.tsx","utils/connectors.tsx","redux/triedEager.tsx","hooks/useEagerConnect.tsx","hooks/useInactiveListener.tsx","utils/baseConnection.tsx","App.tsx"],"names":["useAppDispatch","useDispatch","useAppSelector","useSelector","RPC_NODES","process","getRPCNodeUrl","url","sample","undefined","getChainID","parseInt","setupNetwork","a","provider","window","ethereum","connectedWallet","localStorage","getItem","chainId","console","log","toString","request","method","params","code","chainName","nativeCurrency","name","symbol","decimals","rpcUrls","blockExplorerUrls","error","useAuth","dispatch","useWeb3React","active","connector","activate","deactivate","injected","setItem","walletconnect","logout","useCallback","setState","handleDisconnect","removeItem","login","connectorId","currentConnector","connectorType","UnsupportedChainIdError","catch","NoEthereumProviderError","UserRejectedRequestErrorInjected","UserRejectedRequestErrorWalletConnect","message","RPC_URL","CHAIN_ID","Error","NaN","InjectedConnector","supportedChainIds","handleChainChanged","newChainID","emitDeactivate","emitUpdate","BinanceChain","location","reload","WalletConnectConnector","rpc","bridge","qrcode","pollingInterval","getLibrary","library","ethers","providers","Web3Provider","triedEagerSlice","createSlice","initialState","tried","reducers","state","action","payload","actions","useEagerConnect","useEffect","useInactiveListener","suppress","on","handleConnect","handleAccountsChanged","accounts","length","handleNetworkChanged","networkId","removeListener","BaseConnector","triedEager","Main","lazy","WalletModal","Routes","Header","Footer","App"],"mappings":"+IAAA,iFAIaA,EAAiB,kBAAMC,eACvBC,EAAkDC,K,iCCL/D,0FAQO,IAAMC,EAAY,CAACC,gEAA6CA,iEAEjEC,EAAgB,WAElB,IAAMC,EAAMC,IAAOJ,GAGnB,QAAYK,IAARF,EAKJ,OAAOA,GAQX,IAEMG,EAAa,WACf,OAAOC,SAHKN,IAGa,M,mIC7BhBO,EAAY,uCAAG,gCAAAC,EAAA,yDAClBC,EAAWC,OAAOC,SAClBC,EAAkBC,aAAaC,QAAQ,mBAEzCL,GAAgC,aAApBG,EAJQ,wBAKdG,EAAUV,cALI,kBAQZW,QAAQC,IAAR,YAAiBF,EAAQG,SAAS,MARtB,SASNT,EAASU,QAAQ,CACnBC,OAAQ,6BACRC,OAAQ,CAAC,CAAEN,QAAQ,KAAD,OAAOA,EAAQG,SAAS,SAXlC,yCAkCG,GAlCH,qCAgBsB,OAA9B,KAAqBI,KAhBb,4CAkBEb,EAASU,QAAQ,CACnBC,OAAQ,0BACRC,OAAQ,CACJ,CACIN,QAAQ,KAAD,OAAOA,EAAQG,SAAS,KAC/BK,UAAW,mBACXC,eAAgB,CACZC,KAAM,MACNC,OAAQ,MACRC,SAAU,IAEdC,QAAS,CAAC3B,eACV4B,kBAAmB,CAAC,4BA9B5B,0CAqCJb,QAAQc,MAAM,MAAd,MArCI,mBAsCG,GAtCH,0DAyCD,GAzCC,iEA6ChBd,QAAQc,MAAM,QAAd,MA7CgB,mBA8CT,GA9CS,uCAiDpBd,QAAQc,MAAM,gFAjDM,mBAkDb,GAlDa,yEAAH,qDCsGVC,IAxFC,WACZ,IAAMC,EAAWrC,cACjB,EAAoDsC,cAA5CC,EAAR,EAAQA,OAAQC,EAAhB,EAAgBA,UAAWC,EAA3B,EAA2BA,SAAUC,EAArC,EAAqCA,WAEjCH,IACIC,GAAaG,IACbzB,aAAa0B,QAAQ,iBAAkB,YAChCJ,GAAaK,KACpB3B,aAAa0B,QAAQ,iBAAkB,kBAI/C,IAAME,EAASC,uBAAY,WACvBV,EAASW,aAAS,IAClBN,IAE8C,iBAA1CxB,aAAaC,QAAQ,mBACpB0B,IAAsBI,mBAG3B/B,aAAagC,WAAW,kBACxBhC,aAAagC,WAAW,mBACzB,CAACR,EAAYL,IAEVc,EAAQJ,uBACV,SAACK,GACG,IAAIC,EACJ,GAAmB,YAAfD,EACAC,EAAmBV,SAChB,GAAmB,iBAAfS,EACPC,EAAmBR,QAChB,CACH,IAAMS,EAAgBpC,aAAaC,QAAQ,kBACtB,YAAjBmC,EACAD,EAAmBV,IACK,iBAAjBW,IACPD,EAAmBR,KAIvBQ,EACAZ,EAASY,EAAD,uCAAmB,WAAOlB,GAAP,SAAAtB,EAAA,2DACnBsB,aAAiBoB,KADE,oBAEfF,GAAoBV,IAFL,gCAGQ/B,IAHR,cAMX6B,EAASY,OAAkB5C,GAAW,GAAM+C,OAAM,WAC9CnB,EAASW,aAAS,QAGtB3B,QAAQC,IAAI,UACZwB,KAXW,sBAaRO,GAAoBR,MAC3BQ,EAAiBJ,mBACjB5B,QAAQC,IAAI,UACZwB,KAhBe,+BAoBfX,aAAiBsB,IACjBpC,QAAQC,IAAI,iBAAkB,yBACvBa,aAAiBuB,IACxBrC,QAAQC,IAAI,sBAAuB,2CAC5Ba,aAAiBwB,KACxBN,EAAiBJ,mBACjB5B,QAAQC,IAAI,sBAAuB,4CAEnCD,QAAQC,IAAIa,EAAML,KAAMK,EAAMyB,SAElCd,IA9BmB,4CAAnB,uDAgCLU,OAAM,WACLnB,EAASW,aAAS,IAClBF,QAGJzB,QAAQC,IAAI,uBAAwB,iCACpCwB,OAGR,CAACL,EAAUJ,EAAUS,IAGzB,MAAO,CAAEK,QAAOL,Y,2LC3Fde,EAA8BvD,cAC9BwD,EAAmBpD,cAGzB,QAAgBD,IAAZoD,EACA,MAAM,IAAIE,MAAM,oCAIpB,GAAiBC,MAAbF,EACA,MAAM,IAAIC,MAAM,oDAIb,IAAMpB,EAAW,IAAIsB,IAAkB,CAC1CC,kBAAmB,CAACJ,KAIxBnB,EAASwB,mBAAqB,SAACC,GAC3B,GAAIA,GAAcN,EAQd,OAPAzC,QAAQC,IAAI,SAEZJ,aAAagC,WAAW,uBAGxBP,EAAS0B,iBAMb1B,EAAS2B,WAAW,CAAElD,QAASgD,EAAYtD,SAAUC,OAAOwD,eAE5DxD,OAAOyD,SAASC,UAIpB,IAEa5B,EAAgB,IAAI6B,IAAuB,CACpDC,IAAK,CAAE,EAAGd,GACVe,OAAQ,mCACRC,QAAQ,EACRC,gBANqB,OAUZC,EAAa,SAACjE,GACvB,IAAMkE,EAAU,IAAIC,IAAOC,UAAUC,aAAarE,GAElD,OADAkE,EAAQF,gBAAkB,KACnBE,I,iCC7DX,+CAEaI,EAAkBC,YAAY,CACvCvD,KAAM,aACNwD,aAAc,CACVC,OAAO,GAEXC,SAAU,CACNxC,SAAU,SAACyC,EAAOC,GACdD,EAAMF,MAAQG,EAAOC,YAMlB3C,EAAaoC,EAAgBQ,QAA7B5C,SAEAoC,MAAf,S,iGCEeS,EAdS,WACpB,IAAQpD,EAAaH,cAAbG,SACFJ,EAAWrC,cACTmD,EAAUf,cAAVe,MAER2C,qBAAU,WACmB5E,aAAaC,QAAQ,mBAG1CgC,EAAM,qBAEX,CAACV,EAAUJ,EAAUc,KCgCb4C,EA5Ca,WAAgC,IAAD,EAA9BC,EAA8B,wDACvD,EAAqC1D,cAA7BE,EAAR,EAAQA,UAAWD,EAAnB,EAAmBA,OAAQJ,EAA3B,EAA2BA,MACrBlB,EAAe,UAAGC,aAAaC,QAAQ,yBAAxB,QAA6C,GAClE,EAAkBiB,cAAVe,EAAR,EAAQA,MAER2C,qBAAU,WACN,GAAItD,GAAaA,EAAUyD,KAAO1D,IAAWJ,IAAU6D,EAAU,CAC7D,IAAME,EAAgB,WAClB7E,QAAQC,IAAI,4BACZ6B,EAAM,wBAEJgB,EAAqB,SAAC/C,GACxBC,QAAQC,IAAI,6CAA8CF,GAC1DL,OAAOyD,SAASC,SAChBtB,EAAM,wBAEJgD,EAAwB,SAACC,GAC3B/E,QAAQC,IAAI,gDAAiD8E,GACzDA,EAASC,OAAS,GAClBlD,EAAM,wBAGRmD,EAAuB,SAACC,GAC1BlF,QAAQC,IAAI,+CAAgDiF,GAC5DpD,EAAM,wBAQV,OALAX,EAAUyD,GAAG,UAAWC,GACxB1D,EAAUyD,GAAG,eAAgB9B,GAC7B3B,EAAUyD,GAAG,kBAAmBE,GAChC3D,EAAUyD,GAAG,iBAAkBK,GAExB,WACC9D,EAAUgE,iBACVhE,EAAUgE,eAAe,UAAWN,GACpC1D,EAAUgE,eAAe,eAAgBrC,GACzC3B,EAAUgE,eAAe,kBAAmBL,GAC5C3D,EAAUgE,eAAe,iBAAkBF,QAIxD,CAAC/D,EAAQJ,EAAO6D,EAAUxD,EAAWW,EAAOlC,KC/BpCwF,EAVO,WAClB,IAAMC,EAAaxG,aAAe,SAACuF,GAAD,OAAWA,EAAMiB,WAAWnB,SAG9DM,IAGAE,GAAqBW,I,OCTnBC,EAAOC,gBAAK,kBAAM,+DAClBC,EAAcD,gBAAK,kBAAM,wDACzBE,EAASF,gBAAK,kBAAM,kCACpBG,EAASH,gBAAK,kBAAM,gEACpBI,EAASJ,gBAAK,kBAAM,8DAkBXK,UAdH,WAGR,OAFAR,IAGI,gCACI,cAACM,EAAD,IACA,cAACD,EAAD,IACA,cAACH,EAAD,IACA,cAACE,EAAD,IACA,cAACG,EAAD","file":"static/js/13.6352cde4.chunk.js","sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import sample from 'lodash/sample';\n\n// Error check \".env\" file for BSC_RPC_URL\nif (!process.env.REACT_APP_ETH_MAINNET_RPC_URL_1 || !process.env.REACT_APP_ETH_MAINNET_RPC_URL_2) {\n    throw Error('ETH_RPC_URLs is undefined');\n}\n\n// Array of available nodes to connect to Binance Smart Chain\nexport const RPC_NODES = [process.env.REACT_APP_ETH_MAINNET_RPC_URL_1, process.env.REACT_APP_ETH_MAINNET_RPC_URL_2];\n\nconst getRPCNodeUrl = (): string | undefined => {\n    // get URL\n    const url = sample(RPC_NODES);\n\n    // return undefined if failed to extract valid URL\n    if (url === undefined) {\n        return undefined;\n    }\n\n    // return valid string URL\n    return url;\n};\n\n// Error check \".env\" file for BSC_CHAIN_ID\nif (process.env.REACT_APP_ETH_MAINNET_CHAIN_ID === undefined) {\n    throw new Error('BSC_CHAIN_ID is undefined');\n}\n\nconst chainID = process.env.REACT_APP_ETH_MAINNET_CHAIN_ID;\n\nconst getChainID = () => {\n    return parseInt(chainID, 10);\n};\n\nexport { getRPCNodeUrl, getChainID };\n","import { getChainID, getRPCNodeUrl } from '../utils/getRPC';\n\nexport const setupNetwork = async () => {\n    const provider = window.ethereum;\n    const connectedWallet = localStorage.getItem('_iris_fintech_');\n\n    if (provider && connectedWallet === 'Injected') {\n        const chainId = getChainID();\n        try {\n            try {\n                console.log(`0x${chainId.toString(16)}`);\n                await provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: `0x${chainId.toString(16)}` }],\n                });\n                return true;\n            } catch (switchError) {\n                // This error code indicates that the chain has not been added to MetaMask.\n                if ((switchError as any).code === 4902) {\n                    try {\n                        await provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [\n                                {\n                                    chainId: `0x${chainId.toString(16)}`,\n                                    chainName: 'Ethereum Mainnet',\n                                    nativeCurrency: {\n                                        name: 'ETH',\n                                        symbol: 'eth',\n                                        decimals: 18,\n                                    },\n                                    rpcUrls: [getRPCNodeUrl()],\n                                    blockExplorerUrls: ['https://etherscan.io'],\n                                },\n                            ],\n                        });\n                        return true;\n                    } catch (addError) {\n                        // handle \"add\" error\n                        console.error('add', addError);\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            }\n        } catch (error) {\n            console.error('setup', error);\n            return false;\n        }\n    } else {\n        console.error(\"Can't setup the BSC network on metamask because window.ethereum is undefined\");\n        return false;\n    }\n};\n\nexport const registerToken = async (\n    tokenAddress: string,\n    tokenSymbol: string,\n    tokenDecimals: number,\n    tokenImage: string,\n) => {\n    const provider = window.ethereum;\n\n    const tokenAdded = await (provider as any).request({\n        method: 'wallet_watchAsset',\n        params: {\n            type: 'ERC20',\n            options: {\n                address: tokenAddress,\n                symbol: tokenSymbol,\n                decimals: tokenDecimals,\n                image: tokenImage,\n            },\n        },\n    });\n\n    return tokenAdded;\n};\n","// import necessary library\nimport { useCallback } from 'react';\nimport { useWeb3React, UnsupportedChainIdError } from '@web3-react/core';\nimport {\n    NoEthereumProviderError,\n    UserRejectedRequestError as UserRejectedRequestErrorInjected,\n} from '@web3-react/injected-connector';\n\nimport { UserRejectedRequestError as UserRejectedRequestErrorWalletConnect } from '@web3-react/walletconnect-connector';\n\n// import local components\nimport { injected, walletconnect } from '../utils/connectors';\nimport { useAppDispatch } from '../redux/hook';\nimport { setState } from '../redux/triedEager';\nimport { setupNetwork } from './walletTokenNetwork';\n\nconst useAuth = () => {\n    const dispatch = useAppDispatch();\n    const { active, connector, activate, deactivate } = useWeb3React();\n\n    if (active) {\n        if (connector == injected) {\n            localStorage.setItem('_iris_fintech_', 'Injected');\n        } else if (connector == walletconnect) {\n            localStorage.setItem('_iris_fintech_', 'WalletConnect');\n        }\n    }\n\n    const logout = useCallback(() => {\n        dispatch(setState(false));\n        deactivate();\n\n        if (localStorage.getItem('_iris_fintech_') == 'WalletConnect') {\n            (walletconnect as any).handleDisconnect();\n        }\n\n        localStorage.removeItem('_iris_fintech_');\n        localStorage.removeItem('walletconnect');\n    }, [deactivate, dispatch]);\n\n    const login = useCallback(\n        (connectorId) => {\n            var currentConnector: any;\n            if (connectorId == 'Injected') {\n                currentConnector = injected;\n            } else if (connectorId == 'WalletConnect') {\n                currentConnector = walletconnect;\n            } else {\n                const connectorType = localStorage.getItem('_iris_fintech_');\n                if (connectorType == 'Injected') {\n                    currentConnector = injected;\n                } else if (connectorType == 'WalletConnect') {\n                    currentConnector = walletconnect;\n                }\n            }\n\n            if (currentConnector) {\n                activate(currentConnector, async (error: Error) => {\n                    if (error instanceof UnsupportedChainIdError) {\n                        if (currentConnector == injected) {\n                            const hasSetup = await setupNetwork();\n\n                            if (hasSetup) {\n                                activate(currentConnector, undefined, true).catch(() => {\n                                    dispatch(setState(true));\n                                });\n                            } else {\n                                console.log('logout');\n                                logout();\n                            }\n                        } else if (currentConnector == walletconnect) {\n                            currentConnector.handleDisconnect();\n                            console.log('logout');\n                            logout();\n                        }\n                    } else {\n                        // window.localStorage.removeItem('Wallet');\n                        if (error instanceof NoEthereumProviderError) {\n                            console.log('Provider Error', 'No provider was found');\n                        } else if (error instanceof UserRejectedRequestErrorInjected) {\n                            console.log('Authorization Error', 'Please authorize to access your account');\n                        } else if (error instanceof UserRejectedRequestErrorWalletConnect) {\n                            currentConnector.handleDisconnect();\n                            console.log('Authorization Error', 'Please authorize to access your account');\n                        } else {\n                            console.log(error.name, error.message);\n                        }\n                        logout();\n                    }\n                }).catch(() => {\n                    dispatch(setState(true));\n                    logout();\n                });\n            } else {\n                console.log(\"Can't find connector\", 'The connector config is wrong');\n                logout();\n            }\n        },\n        [activate, dispatch, logout],\n    );\n\n    return { login, logout };\n};\n\nexport default useAuth;\n","// Library Import\nimport { InjectedConnector } from '@web3-react/injected-connector';\nimport { WalletConnectConnector } from '@web3-react/walletconnect-connector';\nimport { ethers } from 'ethers';\n\n// Import TSX File\nimport { getRPCNodeUrl, getChainID } from './getRPC';\n\n// Define Constants\n// const POLLING_INTERVAL: number = 12000;\nconst RPC_URL: string | undefined = getRPCNodeUrl();\nconst CHAIN_ID: number = getChainID();\n\n// Type Check: RPC_URL should be valid string\nif (RPC_URL === undefined) {\n    throw new Error('URL Type Error: should be string');\n}\n\n// Type Check: CHAIN_ID should be valid Number\nif (CHAIN_ID === NaN) {\n    throw new Error('Invalid Numneric Error: should be a valid number');\n}\n\n// Connect to Inject Connector\nexport const injected = new InjectedConnector({\n    supportedChainIds: [CHAIN_ID],\n});\n\n//@ts-ignore\ninjected.handleChainChanged = (newChainID: string | number) => {\n    if (newChainID != CHAIN_ID) {\n        console.log('error');\n\n        localStorage.removeItem('_iris_fintech_');\n\n        //@ts-ignore\n        injected.emitDeactivate();\n\n        return;\n    }\n\n    //@ts-ignore\n    injected.emitUpdate({ chainId: newChainID, provider: window.BinanceChain });\n\n    window.location.reload();\n};\n\n// Connect to Walletconnect Connector\nconst POLLING_INTERVAL = 12000;\n\nexport const walletconnect = new WalletConnectConnector({\n    rpc: { 1: RPC_URL },\n    bridge: 'https://bridge.walletconnect.org',\n    qrcode: true,\n    pollingInterval: POLLING_INTERVAL,\n});\n\n// getLibrary function for Web3Provider\nexport const getLibrary = (provider: any): ethers.providers.Web3Provider => {\n    const library = new ethers.providers.Web3Provider(provider);\n    library.pollingInterval = 12000;\n    return library;\n};\n\nexport const signMessage = async (provider: any, account: string, message: string): Promise<string> => {\n    return provider.getSigner(account).signMessage(message);\n};\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nexport const triedEagerSlice = createSlice({\n    name: 'triedEager',\n    initialState: {\n        tried: false,\n    },\n    reducers: {\n        setState: (state, action: PayloadAction<boolean>) => {\n            state.tried = action.payload;\n        },\n    },\n});\n\n// Action creators are generated for each case reducer function\nexport const { setState } = triedEagerSlice.actions;\n\nexport default triedEagerSlice.reducer;\n","import { useEffect } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport { useAppDispatch } from '../redux/hook';\nimport useAuth from './useAuth';\n\nconst useEagerConnect = () => {\n    const { activate } = useWeb3React();\n    const dispatch = useAppDispatch();\n    const { login } = useAuth();\n\n    useEffect(() => {\n        const connecetedWallet = localStorage.getItem('_iris_fintech_');\n\n        if (connecetedWallet) {\n            login('useEagerConnect');\n        }\n    }, [activate, dispatch, login]); // intentionally only running on mount (make sure it's only mounted once :))\n};\n\nexport default useEagerConnect;\n","import { useEffect } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport useAuth from './useAuth';\n\nconst useInactiveListener = (suppress: boolean = false) => {\n    const { connector, active, error } = useWeb3React();\n    const connectedWallet = localStorage.getItem('_iris_fintech_') ?? '';\n    const { login } = useAuth();\n\n    useEffect((): any => {\n        if (connector && connector.on && !active && !error && !suppress) {\n            const handleConnect = () => {\n                console.log(\"Handling 'connect' event\");\n                login('useInactiveListener');\n            };\n            const handleChainChanged = (chainId: string | number) => {\n                console.log(\"Handling 'chainChanged' event with payload\", chainId);\n                window.location.reload();\n                login('useInactiveListener');\n            };\n            const handleAccountsChanged = (accounts: string[]) => {\n                console.log(\"Handling 'accountsChanged' event with payload\", accounts);\n                if (accounts.length > 0) {\n                    login('useInactiveListener');\n                }\n            };\n            const handleNetworkChanged = (networkId: string | number) => {\n                console.log(\"Handling 'networkChanged' event with payload\", networkId);\n                login('useInactiveListener');\n            };\n\n            connector.on('connect', handleConnect);\n            connector.on('chainChanged', handleChainChanged);\n            connector.on('accountsChanged', handleAccountsChanged);\n            connector.on('networkChanged', handleNetworkChanged);\n\n            return () => {\n                if (connector.removeListener) {\n                    connector.removeListener('connect', handleConnect);\n                    connector.removeListener('chainChanged', handleChainChanged);\n                    connector.removeListener('accountsChanged', handleAccountsChanged);\n                    connector.removeListener('networkChanged', handleNetworkChanged);\n                }\n            };\n        }\n    }, [active, error, suppress, connector, login, connectedWallet]);\n};\n\nexport default useInactiveListener;\n","import useEagerConnect from '../hooks/useEagerConnect';\nimport useInactiveListener from '../hooks/useInactiveListener';\nimport { useAppSelector } from '../redux/hook';\n\nconst BaseConnector = () => {\n    const triedEager = useAppSelector((state) => state.triedEager.tried);\n\n    // handle logic to eagerly connect to the injected ethereum provider, if it exists and has granted access already\n    useEagerConnect();\n\n    // handle logic to connect in reaction to certain events on the injected ethereum provider, if it exists\n    useInactiveListener(!triedEager);\n};\n\nexport default BaseConnector;\n","import React, { lazy } from 'react';\n\nconst Main = lazy(() => import('./components/Main'));\nconst WalletModal = lazy(() => import('./components/WalletModal'));\nconst Routes = lazy(() => import('./route'));\nconst Header = lazy(() => import('./components/Header'));\nconst Footer = lazy(() => import('./components/Footer/Footer'));\n\nimport BaseConnector from './utils/baseConnection';\n\nconst App = () => {\n    BaseConnector();\n\n    return (\n        <div>\n            <Header />\n            <Routes />\n            <Main />\n            <WalletModal />\n            <Footer />\n        </div>\n    );\n};\n\nexport default App;\n"],"sourceRoot":""}