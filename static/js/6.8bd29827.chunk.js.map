{"version":3,"sources":["redux/hook.tsx","utils/getRPC.tsx","hooks/walletTokenNetwork.tsx","hooks/useAuth.tsx","utils/connectors.tsx","redux/triedEager.tsx","hooks/useEagerConnect.tsx","hooks/useInactiveListener.tsx","utils/baseConnection.tsx","App.tsx"],"names":["useAppDispatch","useDispatch","useAppSelector","useSelector","RPC_NODES","process","getRPCNodeUrl","url","sample","undefined","getChainID","parseInt","setupNetwork","a","provider","window","ethereum","chainId","request","method","params","toString","code","chainName","nativeCurrency","name","symbol","decimals","rpcUrls","blockExplorerUrls","console","error","useAuth","dispatch","useWeb3React","active","connector","activate","deactivate","injected","localStorage","setItem","walletconnect","logout","useCallback","setState","getItem","handleDisconnect","removeItem","login","connectorId","currentConnector","connectorType","UnsupportedChainIdError","catch","NoEthereumProviderError","log","UserRejectedRequestErrorInjected","UserRejectedRequestErrorWalletConnect","message","RPC_URL","Web3","givenProvider","CHAIN_ID","Error","NaN","InjectedConnector","supportedChainIds","handleChainChanged","newChainID","emitDeactivate","emitUpdate","BinanceChain","location","reload","WalletConnectConnector","rpc","bridge","qrcode","pollingInterval","getLibrary","triedEagerSlice","createSlice","initialState","tried","reducers","state","action","payload","actions","useEagerConnect","useEffect","useInactiveListener","suppress","connectedWallet","on","handleConnect","handleAccountsChanged","accounts","length","handleNetworkChanged","networkId","removeListener","BaseConnector","triedEager","Main","lazy","WalletModal","Routes","Header","Footer","App"],"mappings":"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","file":"static/js/6.8bd29827.chunk.js","sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import sample from 'lodash/sample';\n\n// Error check \".env\" file for BSC_RPC_URL\nif (!process.env.REACT_APP_ETH_MAINNET_RPC_URL_1 || !process.env.REACT_APP_ETH_MAINNET_RPC_URL_2) {\n    throw Error('ETH_RPC_URLs is undefined');\n}\n\n// Array of available nodes to connect to Binance Smart Chain\nexport const RPC_NODES = [process.env.REACT_APP_ETH_MAINNET_RPC_URL_1, process.env.REACT_APP_ETH_MAINNET_RPC_URL_2];\n\nconst getRPCNodeUrl = (): string | undefined => {\n    // get URL\n    const url = sample(RPC_NODES);\n\n    // return undefined if failed to extract valid URL\n    if (url === undefined) {\n        return undefined;\n    }\n\n    // return valid string URL\n    return url;\n};\n\n// Error check \".env\" file for BSC_CHAIN_ID\nif (process.env.REACT_APP_ETH_MAINNET_CHAIN_ID === undefined) {\n    throw new Error('BSC_CHAIN_ID is undefined');\n}\n\nconst chainID = process.env.REACT_APP_ETH_MAINNET_CHAIN_ID;\n\nconst getChainID = () => {\n    return parseInt(chainID, 10);\n};\n\nexport { getRPCNodeUrl, getChainID };\n","import { getChainID, getRPCNodeUrl } from '../utils/getRPC';\n\nexport const setupNetwork = async () => {\n    const provider = window.ethereum;\n\n    if (provider) {\n        const chainId = getChainID();\n        try {\n            try {\n                await provider.request({\n                    method: 'wallet_switchEthereumChain',\n                    params: [{ chainId: `0x${chainId.toString(16)}` }],\n                });\n                return true;\n            } catch (switchError) {\n                // This error code indicates that the chain has not been added to MetaMask.\n                if ((switchError as any).code === 4902) {\n                    try {\n                        await provider.request({\n                            method: 'wallet_addEthereumChain',\n                            params: [\n                                {\n                                    chainId: `0x${chainId.toString(16)}`,\n                                    chainName: 'Ethereum Mainnet',\n                                    nativeCurrency: {\n                                        name: 'ETH',\n                                        symbol: 'eth',\n                                        decimals: 18,\n                                    },\n                                    rpcUrls: [getRPCNodeUrl()],\n                                    blockExplorerUrls: ['https://etherscan.io'],\n                                },\n                            ],\n                        });\n                        return true;\n                    } catch (addError) {\n                        // handle \"add\" error\n                        console.error('add', addError);\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            }\n        } catch (error) {\n            console.error('setup', error);\n            return false;\n        }\n    } else {\n        console.error(\"Can't setup the BSC network on metamask because window.ethereum is undefined\");\n        return false;\n    }\n};\n\nexport const registerToken = async (\n    tokenAddress: string,\n    tokenSymbol: string,\n    tokenDecimals: number,\n    tokenImage: string,\n) => {\n    const provider = window.ethereum;\n\n    const tokenAdded = await (provider as any).request({\n        method: 'wallet_watchAsset',\n        params: {\n            type: 'ERC20',\n            options: {\n                address: tokenAddress,\n                symbol: tokenSymbol,\n                decimals: tokenDecimals,\n                image: tokenImage,\n            },\n        },\n    });\n\n    return tokenAdded;\n};\n","// import necessary library\nimport { useCallback } from 'react';\nimport { useWeb3React, UnsupportedChainIdError } from '@web3-react/core';\nimport {\n    NoEthereumProviderError,\n    UserRejectedRequestError as UserRejectedRequestErrorInjected,\n} from '@web3-react/injected-connector';\n\nimport { UserRejectedRequestError as UserRejectedRequestErrorWalletConnect } from '@web3-react/walletconnect-connector';\n\n// import local components\nimport { injected, walletconnect } from '../utils/connectors';\nimport { useAppDispatch } from '../redux/hook';\nimport { setState } from '../redux/triedEager';\nimport { setupNetwork } from './walletTokenNetwork';\n\nconst useAuth = () => {\n    const dispatch = useAppDispatch();\n    const { active, connector, activate, deactivate } = useWeb3React();\n\n    if (active) {\n        if (connector == injected) {\n            localStorage.setItem('_iris_fintech_', 'Injected');\n        } else if (connector == walletconnect) {\n            localStorage.setItem('_iris_fintech_', 'WalletConnect');\n        }\n    }\n\n    const logout = useCallback(() => {\n        dispatch(setState(false));\n        deactivate();\n\n        if (localStorage.getItem('_iris_fintech_') == 'WalletConnect') {\n            (walletconnect as any).handleDisconnect();\n        }\n\n        localStorage.removeItem('_iris_fintech_');\n        localStorage.removeItem('walletconnect');\n    }, [deactivate, dispatch]);\n\n    const login = useCallback(\n        (connectorId) => {\n            var currentConnector: any;\n            if (connectorId == 'Injected') {\n                currentConnector = injected;\n            } else if (connectorId == 'WalletConnect') {\n                currentConnector = walletconnect;\n            } else {\n                const connectorType = localStorage.getItem('_iris_fintech_');\n                if (connectorType == 'Injected') {\n                    currentConnector = injected;\n                } else if (connectorType == 'WalletConnect') {\n                    currentConnector = walletconnect;\n                }\n            }\n\n            if (currentConnector) {\n                activate(currentConnector, async (error: Error) => {\n                    if (error instanceof UnsupportedChainIdError) {\n                        if (currentConnector == injected) {\n                            const hasSetup = await setupNetwork();\n\n                            if (hasSetup) {\n                                activate(currentConnector, undefined, true).catch(() => {\n                                    dispatch(setState(true));\n                                });\n                            } else {\n                                logout();\n                            }\n                        } else if (currentConnector == walletconnect) {\n                            currentConnector.handleDisconnect();\n\n                            logout();\n                        }\n                    } else {\n                        if (error instanceof NoEthereumProviderError) {\n                            console.log('Provider Error', 'No provider was found');\n                        } else if (error instanceof UserRejectedRequestErrorInjected) {\n                            console.log('Authorization Error', 'Please authorize to access your account');\n                        } else if (error instanceof UserRejectedRequestErrorWalletConnect) {\n                            currentConnector.handleDisconnect();\n                            console.log('Authorization Error', 'Please authorize to access your account');\n                        } else {\n                            console.log(error.name, error.message);\n                        }\n                        logout();\n                    }\n                }).catch(() => {\n                    dispatch(setState(true));\n                    logout();\n                });\n            } else {\n                console.log(\"Can't find connector\", 'The connector config is wrong');\n                logout();\n            }\n        },\n        [activate, dispatch, logout],\n    );\n\n    return { login, logout };\n};\n\nexport default useAuth;\n","// Library Import\nimport { InjectedConnector } from '@web3-react/injected-connector';\nimport { WalletConnectConnector } from '@web3-react/walletconnect-connector';\nimport Web3 from 'web3';\n\nconst web3 = new Web3(Web3.givenProvider);\n\n// Import TSX File\nimport { getRPCNodeUrl, getChainID } from './getRPC';\n\n// Define Constants\n// const POLLING_INTERVAL: number = 12000;\nconst RPC_URL: string | undefined = getRPCNodeUrl();\nconst CHAIN_ID: number = getChainID();\n\n// Type Check: RPC_URL should be valid string\nif (RPC_URL === undefined) {\n    throw new Error('URL Type Error: should be string');\n}\n\n// Type Check: CHAIN_ID should be valid Number\nif (CHAIN_ID === NaN) {\n    throw new Error('Invalid Numneric Error: should be a valid number');\n}\n\n// Connect to Inject Connector\nexport const injected = new InjectedConnector({\n    supportedChainIds: [CHAIN_ID],\n});\n\n//@ts-ignore\ninjected.handleChainChanged = (newChainID: string | number) => {\n    if (newChainID != CHAIN_ID) {\n        localStorage.removeItem('_iris_fintech_');\n\n        //@ts-ignore\n        injected.emitDeactivate();\n\n        return;\n    }\n\n    //@ts-ignore\n    injected.emitUpdate({ chainId: newChainID, provider: window.BinanceChain });\n\n    window.location.reload();\n};\n\n// Connect to Walletconnect Connector\nconst POLLING_INTERVAL = 12000;\n\nexport const walletconnect = new WalletConnectConnector({\n    rpc: { 1: RPC_URL },\n    bridge: 'https://bridge.walletconnect.org',\n    qrcode: true,\n    pollingInterval: POLLING_INTERVAL,\n});\n\n// getLibrary function for Web3Provider\nexport const getLibrary = (provider: any): Web3 => {\n    const library = new Web3(provider);\n    return library;\n};\n\nexport const signMessage = async (provider: any, account: string, msg: string) => {\n    // return provider.eth.sign(provider.utils.utf8ToHex(message), account);\n    const prefix = '\\x19Ethereum Signed Message:\\n' + msg.length;\n    const msgHash = Web3.utils.keccak256(prefix + msg);\n\n    await provider\n        .request({\n            method: 'personal_sign',\n            params: [account, msgHash],\n        })\n        .then((response: any) => {\n            console.log(response);\n\n            web3.eth.personal\n                .ecRecover(msgHash, response)\n                .then((res: any) => {\n                    console.log(res);\n                })\n                .catch((err: any) => {\n                    console.log(err);\n                });\n        })\n        .catch((error: any) => {\n            console.log(error);\n        });\n};\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nexport const triedEagerSlice = createSlice({\n    name: 'triedEager',\n    initialState: {\n        tried: false,\n    },\n    reducers: {\n        setState: (state, action: PayloadAction<boolean>) => {\n            state.tried = action.payload;\n        },\n    },\n});\n\n// Action creators are generated for each case reducer function\nexport const { setState } = triedEagerSlice.actions;\n\nexport default triedEagerSlice.reducer;\n","import { useEffect } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport { useAppDispatch } from '../redux/hook';\nimport useAuth from './useAuth';\n\nconst useEagerConnect = () => {\n    const { activate } = useWeb3React();\n    const dispatch = useAppDispatch();\n    const { login } = useAuth();\n\n    useEffect(() => {\n        const connecetedWallet = localStorage.getItem('_iris_fintech_');\n\n        if (connecetedWallet) {\n            login('useEagerConnect');\n        }\n    }, [activate, dispatch, login]); // intentionally only running on mount (make sure it's only mounted once :))\n};\n\nexport default useEagerConnect;\n","import { useEffect } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport useAuth from './useAuth';\n\nconst useInactiveListener = (suppress: boolean = false) => {\n    const { connector, active, error } = useWeb3React();\n    const connectedWallet = localStorage.getItem('_iris_fintech_') ?? '';\n    const { login } = useAuth();\n\n    useEffect((): any => {\n        if (connector && connector.on && !active && !error && !suppress) {\n            const handleConnect = () => {\n                console.log(\"Handling 'connect' event\");\n                login('useInactiveListener');\n            };\n            const handleChainChanged = (chainId: string | number) => {\n                console.log(\"Handling 'chainChanged' event with payload\", chainId);\n                window.location.reload();\n                login('useInactiveListener');\n            };\n            const handleAccountsChanged = (accounts: string[]) => {\n                console.log(\"Handling 'accountsChanged' event with payload\", accounts);\n                if (accounts.length > 0) {\n                    login('useInactiveListener');\n                }\n            };\n            const handleNetworkChanged = (networkId: string | number) => {\n                console.log(\"Handling 'networkChanged' event with payload\", networkId);\n                login('useInactiveListener');\n            };\n\n            connector.on('connect', handleConnect);\n            connector.on('chainChanged', handleChainChanged);\n            connector.on('accountsChanged', handleAccountsChanged);\n            connector.on('networkChanged', handleNetworkChanged);\n\n            return () => {\n                if (connector.removeListener) {\n                    connector.removeListener('connect', handleConnect);\n                    connector.removeListener('chainChanged', handleChainChanged);\n                    connector.removeListener('accountsChanged', handleAccountsChanged);\n                    connector.removeListener('networkChanged', handleNetworkChanged);\n                }\n            };\n        }\n    }, [active, error, suppress, connector, login, connectedWallet]);\n};\n\nexport default useInactiveListener;\n","import useEagerConnect from '../hooks/useEagerConnect';\nimport useInactiveListener from '../hooks/useInactiveListener';\nimport { useAppSelector } from '../redux/hook';\n\nconst BaseConnector = () => {\n    const triedEager = useAppSelector((state) => state.triedEager.tried);\n\n    // handle logic to eagerly connect to the injected ethereum provider, if it exists and has granted access already\n    useEagerConnect();\n\n    // handle logic to connect in reaction to certain events on the injected ethereum provider, if it exists\n    useInactiveListener(!triedEager);\n};\n\nexport default BaseConnector;\n","import React, { lazy } from 'react';\n\nconst Main = lazy(() => import('./components/Main'));\nconst WalletModal = lazy(() => import('./components/WalletModal'));\nconst Routes = lazy(() => import('./route'));\nconst Header = lazy(() => import('./components/Header'));\nconst Footer = lazy(() => import('./components/Footer/Footer'));\n\nimport BaseConnector from './utils/baseConnection';\n\nconst App = () => {\n    BaseConnector();\n\n    return (\n        <div>\n            <Header />\n            <Routes />\n            <Main />\n            <WalletModal />\n            <Footer />\n        </div>\n    );\n};\n\nexport default App;\n"],"sourceRoot":""}