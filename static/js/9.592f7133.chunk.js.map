{"version":3,"sources":["utils/getRPC.tsx","utils/connectors.tsx","redux/triedEager.tsx","redux/hook.tsx","hooks/walletTokenNetwork.tsx","hooks/useAuth.tsx","hooks/useEagerConnect.tsx","hooks/useInactiveListener.tsx","utils/baseConnection.tsx","App.tsx"],"names":["RPC_NODES","process","getRPCNodeUrl","url","sample","undefined","getChainID","parseInt","RPC_URL","CHAIN_ID","Error","NaN","injected","InjectedConnector","supportedChainIds","handleChainChanged","newChainID","console","log","localStorage","removeItem","emitDeactivate","emitUpdate","chainId","provider","window","BinanceChain","location","reload","getLibrary","library","ethers","providers","Web3Provider","pollingInterval","triedEagerSlice","createSlice","name","initialState","tried","reducers","setState","state","action","payload","actions","useAppDispatch","useDispatch","useAppSelector","useSelector","setupNetwork","a","ethereum","connectedWallet","getItem","request","method","params","toString","chainName","nativeCurrency","symbol","decimals","rpcUrls","blockExplorerUrls","error","useAuth","dispatch","useWeb3React","activate","deactivate","logout","useCallback","login","connector","UnsupportedChainIdError","catch","NoEthereumProviderError","UserRejectedRequestErrorInjected","message","useEagerConnect","useEffect","useInactiveListener","suppress","active","on","handleConnect","handleAccountsChanged","accounts","length","handleNetworkChanged","networkId","removeListener","BaseConnector","triedEager","Main","lazy","Routes","Header","Footer","App"],"mappings":"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","file":"static/js/9.592f7133.chunk.js","sourcesContent":["import sample from 'lodash/sample';\n\n// Error check \".env\" file for BSC_RPC_URL\nif (!process.env.REACT_APP_ETH_MAINNET_RPC_URL_1 || !process.env.REACT_APP_ETH_MAINNET_RPC_URL_2) {\n    throw Error('ETH_RPC_URLs is undefined');\n}\n\n// Array of available nodes to connect to Binance Smart Chain\nexport const RPC_NODES = [process.env.REACT_APP_ETH_MAINNET_RPC_URL_1, process.env.REACT_APP_ETH_MAINNET_RPC_URL_2];\n\nconst getRPCNodeUrl = (): string | undefined => {\n    // get URL\n    const url = sample(RPC_NODES);\n\n    // return undefined if failed to extract valid URL\n    if (url === undefined) {\n        return undefined;\n    }\n\n    // return valid string URL\n    return url;\n};\n\n// Error check \".env\" file for BSC_CHAIN_ID\nif (process.env.REACT_APP_ETH_MAINNET_CHAIN_ID === undefined) {\n    throw new Error('BSC_CHAIN_ID is undefined');\n}\n\nconst chainID = process.env.REACT_APP_ETH_MAINNET_CHAIN_ID;\n\nconst getChainID = () => {\n    return parseInt(chainID, 10);\n};\n\nexport { getRPCNodeUrl, getChainID };\n","// Library Import\nimport { InjectedConnector } from '@web3-react/injected-connector';\nimport { ethers } from 'ethers';\n\n// Import TSX File\nimport { getRPCNodeUrl, getChainID } from './getRPC';\n\n// Define Constants\n// const POLLING_INTERVAL: number = 12000;\nconst RPC_URL: string | undefined = getRPCNodeUrl();\nconst CHAIN_ID: number = getChainID();\n\n// Type Check: RPC_URL should be valid string\nif (RPC_URL === undefined) {\n    throw new Error('URL Type Error: should be string');\n}\n\n// Type Check: CHAIN_ID should be valid Number\nif (CHAIN_ID === NaN) {\n    throw new Error('Invalid Numneric Error: should be a valid number');\n}\n\n// Connect to Inject Connector\nexport const injected = new InjectedConnector({\n    supportedChainIds: [CHAIN_ID],\n});\n\n//@ts-ignore\ninjected.handleChainChanged = (newChainID: string | number) => {\n    if (newChainID != CHAIN_ID) {\n        console.log('error');\n\n        localStorage.removeItem('Wallet');\n\n        //@ts-ignore\n        injected.emitDeactivate();\n\n        return;\n    }\n\n    //@ts-ignore\n    injected.emitUpdate({ chainId: newChainID, provider: window.BinanceChain });\n\n    window.location.reload();\n};\n\n// getLibrary function for Web3Provider\nexport const getLibrary = (provider: any): ethers.providers.Web3Provider => {\n    const library = new ethers.providers.Web3Provider(provider);\n    library.pollingInterval = 12000;\n    return library;\n};\n\nexport const signMessage = async (provider: any, account: string, message: string): Promise<string> => {\n    return provider.getSigner(account).signMessage(message);\n};\n","import { createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nexport const triedEagerSlice = createSlice({\n    name: 'triedEager',\n    initialState: {\n        tried: false,\n    },\n    reducers: {\n        setState: (state, action: PayloadAction<boolean>) => {\n            state.tried = action.payload;\n        },\n    },\n});\n\n// Action creators are generated for each case reducer function\nexport const { setState } = triedEagerSlice.actions;\n\nexport default triedEagerSlice.reducer;\n","import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { getChainID, getRPCNodeUrl } from '../utils/getRPC';\n\nexport const setupNetwork = async () => {\n    const provider = window.ethereum;\n    const connectedWallet = localStorage.getItem('Wallet');\n\n    if (provider && connectedWallet === 'Injected') {\n        const chainId = getChainID();\n        try {\n            await provider.request({\n                method: 'wallet_addEthereumChain',\n                params: [\n                    {\n                        chainId: `0x${chainId.toString(16)}`,\n                        chainName: 'Binance Smart Chain Mainnet',\n                        nativeCurrency: {\n                            name: 'BNB',\n                            symbol: 'bnb',\n                            decimals: 18,\n                        },\n                        rpcUrls: [getRPCNodeUrl()],\n                        blockExplorerUrls: ['https://bscscan.com/'],\n                    },\n                ],\n            });\n            return true;\n        } catch (error) {\n            console.error('setup', error);\n            return false;\n        }\n    } else {\n        console.error(\"Can't setup the BSC network on metamask because window.ethereum is undefined\");\n        return false;\n    }\n};\n\nexport const registerToken = async (\n    tokenAddress: string,\n    tokenSymbol: string,\n    tokenDecimals: number,\n    tokenImage: string,\n) => {\n    const provider = window.ethereum;\n\n    const tokenAdded = await (provider as any).request({\n        method: 'wallet_watchAsset',\n        params: {\n            type: 'ERC20',\n            options: {\n                address: tokenAddress,\n                symbol: tokenSymbol,\n                decimals: tokenDecimals,\n                image: tokenImage,\n            },\n        },\n    });\n\n    return tokenAdded;\n};\n","// import necessary library\nimport { useCallback } from 'react';\nimport { useWeb3React, UnsupportedChainIdError } from '@web3-react/core';\nimport {\n    NoEthereumProviderError,\n    UserRejectedRequestError as UserRejectedRequestErrorInjected,\n} from '@web3-react/injected-connector';\n\n// import local components\nimport { injected } from '../utils/connectors';\nimport { useAppDispatch } from '../redux/hook';\nimport { setState } from '../redux/triedEager';\nimport { setupNetwork } from './walletTokenNetwork';\n\nconst useAuth = () => {\n    const dispatch = useAppDispatch();\n    const { activate, deactivate } = useWeb3React();\n\n    const logout = useCallback(() => {\n        dispatch(setState(false));\n        deactivate();\n        localStorage.removeItem('Wallet');\n    }, [deactivate, dispatch]);\n\n    const login = useCallback(() => {\n        const connector = injected;\n        if (connector) {\n            activate(connector, async (error: Error) => {\n                if (error instanceof UnsupportedChainIdError) {\n                    const hasSetup = await setupNetwork();\n\n                    if (hasSetup) {\n                        activate(connector, undefined, true).catch(() => {\n                            dispatch(setState(true));\n                        });\n                    } else {\n                        console.log('logout');\n                        logout();\n                    }\n                } else {\n                    // window.localStorage.removeItem('Wallet');\n                    if (error instanceof NoEthereumProviderError) {\n                        console.log('Provider Error', 'No provider was found');\n                    } else if (error instanceof UserRejectedRequestErrorInjected) {\n                        console.log('Authorization Error', 'Please authorize to access your account');\n                    } else {\n                        console.log(error.name, error.message);\n                    }\n                    logout();\n                }\n            }).catch(() => {\n                dispatch(setState(true));\n            });\n        } else {\n            console.log(\"Can't find connector\", 'The connector config is wrong');\n        }\n    }, [activate, dispatch, logout]);\n\n    return { login, logout };\n};\n\nexport default useAuth;\n","import { useEffect } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport { useAppDispatch } from '../redux/hook';\nimport useAuth from './useAuth';\n\nconst useEagerConnect = () => {\n    const { activate } = useWeb3React();\n    const dispatch = useAppDispatch();\n    const { login } = useAuth();\n\n    useEffect(() => {\n        const connecetedWallet = localStorage.getItem('Wallet');\n\n        if (connecetedWallet === 'Injected') {\n            login();\n        }\n    }, [activate, dispatch, login]); // intentionally only running on mount (make sure it's only mounted once :))\n};\n\nexport default useEagerConnect;\n","import { useEffect } from 'react';\nimport { useWeb3React } from '@web3-react/core';\nimport useAuth from './useAuth';\n\nconst useInactiveListener = (suppress: boolean = false) => {\n    const { connector, active, error } = useWeb3React();\n    const connectedWallet = localStorage.getItem('Wallet') ?? '';\n    const { login } = useAuth();\n\n    useEffect((): any => {\n        if (connector && connector.on && !active && !error && !suppress) {\n            const handleConnect = () => {\n                console.log(\"Handling 'connect' event\");\n                login();\n            };\n            const handleChainChanged = (chainId: string | number) => {\n                console.log(\"Handling 'chainChanged' event with payload\", chainId);\n                window.location.reload();\n                login();\n            };\n            const handleAccountsChanged = (accounts: string[]) => {\n                console.log(\"Handling 'accountsChanged' event with payload\", accounts);\n                if (accounts.length > 0) {\n                    login();\n                }\n            };\n            const handleNetworkChanged = (networkId: string | number) => {\n                console.log(\"Handling 'networkChanged' event with payload\", networkId);\n                login();\n            };\n\n            connector.on('connect', handleConnect);\n            connector.on('chainChanged', handleChainChanged);\n            connector.on('accountsChanged', handleAccountsChanged);\n            connector.on('networkChanged', handleNetworkChanged);\n\n            return () => {\n                if (connector.removeListener) {\n                    connector.removeListener('connect', handleConnect);\n                    connector.removeListener('chainChanged', handleChainChanged);\n                    connector.removeListener('accountsChanged', handleAccountsChanged);\n                    connector.removeListener('networkChanged', handleNetworkChanged);\n                }\n            };\n        }\n    }, [active, error, suppress, connector, login, connectedWallet]);\n};\n\nexport default useInactiveListener;\n","import useEagerConnect from '../hooks/useEagerConnect';\nimport useInactiveListener from '../hooks/useInactiveListener';\nimport { useAppSelector } from '../redux/hook';\n\nconst BaseConnector = () => {\n    const triedEager = useAppSelector((state) => state.triedEager.tried);\n\n    // handle logic to eagerly connect to the injected ethereum provider, if it exists and has granted access already\n    useEagerConnect();\n\n    // handle logic to connect in reaction to certain events on the injected ethereum provider, if it exists\n    useInactiveListener(!triedEager);\n};\n\nexport default BaseConnector;\n","import React, { lazy } from 'react';\n\nconst Main = lazy(() => import('./components/Main'));\n// const Account = lazy(() => import('./components/Account'));\nconst Routes = lazy(() => import('./route'));\nconst Header = lazy(() => import('./components/Header'));\nconst Footer = lazy(() => import('./components/Footer/Footer'));\n\nimport BaseConnector from './utils/baseConnection';\n\nconst App = () => {\n    BaseConnector();\n\n    return (\n        <div>\n            <Header />\n            <Routes />\n            <Main />\n            {/* <Account /> */}\n            <Footer />\n        </div>\n    );\n};\n\nexport default App;\n"],"sourceRoot":""}